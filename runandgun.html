<!DOCTYPE html>
<html lang="en">
    <head>
        <title>three.js webgl - geometry - cube</title>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
        <link type="text/css" rel="stylesheet" href="main.css">
    </head>
    <body>

        <script type="module">

            import * as THREE from '../build/three.module.js';

            var camera, light, scene, renderer;
            var mesh;

            var radius=2000;
            var num=25;

            var Xaxis=[0,-200/2, 200/2];
            var Yaxis=[0,30];

            var obstacles=[];
            var ObSpeed=3;

            let controls = {};

            let player = {
                height: 25,
                jumpHeight: 4,
                gravity: .2,
                velocity: 0,

                playerJumps: false
               };

      document.addEventListener('keydown', ({ keyCode }) => { controls[keyCode] = true });
      document.addEventListener('keyup', ({ keyCode }) => { controls[keyCode] = false });            
            init();

            animate();
                
                camera.position.set(0, player.height, 5);
                camera.lookAt(new THREE.Vector3(0, player.height, 0));


            function init() {


                camera = new THREE.PerspectiveCamera( 70, window.innerWidth / window.innerHeight, 1, 1000 );
                /*camera.position.z = 400;
                camera.position.y = 35;*/

                scene = new THREE.Scene();


                const texture = new THREE.TextureLoader().load( 'textures/crate.gif' );

                const geometry = new THREE.BoxGeometry( 20, 20, 20 );
                const material = new THREE.MeshBasicMaterial( { map: texture } );

                

                for(var i =0;i<num;i++) {
                mesh = new THREE.Mesh( geometry, material );
                scene.add( mesh );
                mesh.position.set(Xaxis[Math.floor(Math.random()*3)],Yaxis[Math.floor(Math.random()*2)],radius/2-radius*Math.random())

                obstacles.push(mesh);
                }


                var meshFloor = new THREE.Mesh(
                new THREE.PlaneGeometry(1000,1000,1000,1000),
                new THREE.MeshBasicMaterial({color:0xffffff, wireframe:false})
                );
                meshFloor.rotation.x -= Math.PI / 2; // Rotate the floor 90 degrees

                meshFloor.position.y -= 15; 
                scene.add(meshFloor);


                renderer = new THREE.WebGLRenderer( { antialias: true } );
                renderer.setPixelRatio( window.devicePixelRatio );
                renderer.setSize( window.innerWidth, window.innerHeight );
                document.body.appendChild( renderer.domElement );


                collision();

                window.addEventListener( 'resize', onWindowResize );
               window.addEventListener('keydown', movePlayer, false);
            }
           
            function collision(){
                for(var i =0;i<obstacles.length;i++){
                if(((camera.position.x>obstacles[i].position.x-10)&&(camera.position.x<obstacles[i].position.x+10)) && 
                    ((camera.position.x>obstacles[i].position.y-10)&&(camera.position.x<obstacles[i].position.y+10)) &&
                    ((camera.position.x>obstacles[i].position.z-10)&&(camera.position.x<obstacles[i].position.z+10))){
                    alert('hit');
                }
            }
            }



            function onWindowResize() {

                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();

                renderer.setSize( window.innerWidth, window.innerHeight );

            }
           
            function animate() {

                requestAnimationFrame( animate );
                control();
                ixMovementUpdate();

                for( var i = 0; i<obstacles.length;i++){
                    if(obstacles[i].position.z>=camera.position.z){
                        obstacles[i].position.z=-600;
                    }else{
                    obstacles[i].position.z += ObSpeed;
                    }
                   // console.log(camera.position);
                }


                renderer.render( scene, camera );

            }

          
            function control(){

              if(controls[32]) { // space
            
              if(player.jumps) 

                return false;

              player.jumps = true;
              player.velocity =- player.jumpHeight;
            }
          }



        function ixMovementUpdate() { //jump and hit floor
        
            player.velocity += player.gravity;
            camera.position.y -= player.velocity;

            if(camera.position.y < player.height) {

              camera.position.y = player.height;
              player.jumps = false;
            }
        }
           

        function movePlayer( evt ) {

        var dir = new THREE.Vector3( 100, 0, 0);
        var crouch = new THREE.Vector3(0 , 50 , 0);
       
        switch( evt.key ) {

         
          case 'a':
          if(camera.position.x == -100)
         {
 
          
         }
         else{
            camera.position.sub(dir);
           
           }
            break;

          case 'd':
          if(camera.position.x == 100)
         {
 
          
         }
          else{ 
            camera.position.add(dir);
               
               }
                break;

           case 'c':
                if(camera.position.y==25){
                    player.height=15;
                }else if(camera.position.y==15){
                    player.height=25;
                }
                break;

        }
             
      window.addEventListener('keydown', movePlayer, false);

}

        </script>

    </body>
</html>