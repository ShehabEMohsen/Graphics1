<!DOCTYPE html>
<html lang="en">
    <head>
        <title>three.js webgl - geometry - cube</title>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
        <link type="text/css" rel="stylesheet" href="main.css">


        <style>
            #blocker {
                position: absolute;
                width: 100%;
                height: 100%;
                background-color: rgba(0,0,0,0.5);
            }

            #instructions {
                width: 100%;
                height: 100%;

                display: flex;
                flex-direction: column;
                justify-content: center;
                align-items: center;

                text-align: center;
                font-size: 14px;
                cursor: pointer;
            }
        </style>

    </head>
    <body>
<div id="blocker">
            <div id="instructions">
                <p style="font-size:36px">
                    RUN & GUN
                </p>
                <p>
                    left: A<br/>
                    right: D<br/>
                    down: S<br/>
                    Jump: SPACE<br/>
                    aim: MOUSE
                </p>
            </div>
        </div>

        <script type="module">

            import * as THREE from '../build/three.module.js';
           

            import { PointerLockControls } from './jsm/controls/PointerLockControls.js';

            var  light,parameters;

            var mesh, meshFloor2, meshFloor;
            var camera = new THREE.PerspectiveCamera( 70, window.innerWidth / window.innerHeight, 1, 10000 );

            
            let renderer = new  THREE.WebGLRenderer();
            
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap; // default THREE.PCFShadowMap
            let scene = new THREE.Scene();

            var radius= 2000;
            var num=12;
      
            var Xaxis=[0,-200/2, 200/2];
            var Yaxis=[0,30];

            var obstacles=[];
            var ObSpeed=3;

            let controls = {};

            let player = {
                height: 25,
                jumpHeight: 4,
                gravity: .2,
                velocity: 0,

                playerJumps: false
               };

      document.addEventListener('keydown', ({ keyCode }) => { controls[keyCode] = true });
      document.addEventListener('keyup', ({ keyCode }) => { controls[keyCode] = false });            
            
            init();

            animate();
                


            function init() {

                // width/height to measure aspect ratio
                camera = new THREE.PerspectiveCamera( 70, window.innerWidth / window.innerHeight, 1, 10000 );
                camera.position.set(0, player.height, 5);
                camera.lookAt(new THREE.Vector3(0, player.height, 0));
                light = new THREE.DirectionalLight('white',0.3);
                light.position.set(0, 1000, 700);
                light.castShadow = true;
                scene.add(light);
                light.shadow.mapSize.width=500;
                light.shadow.mapSize.height=500;
                light.shadow.camera.near=1;

                light.shadow.camera.far=500;
                //scene = new THREE.Scene();
                 const geometry = new THREE.BoxGeometry( 20, 20, 20 );
               

                //in the htdocs files
                const texture = new THREE.TextureLoader().load( 'textures/crate.gif' );
              

              let mousecontrols ; 

               mousecontrols = new PointerLockControls(camera,renderer.domElement);


                const blocker = document.getElementById( 'blocker' );
                const instructions = document.getElementById( 'instructions' );

                instructions.addEventListener( 'click', function () {

                    mousecontrols.lock();

                },false );

                mousecontrols.addEventListener( 'lock', function () {

                    instructions.style.display = 'none';
                    blocker.style.display = 'none';

                } );

                mousecontrols.addEventListener( 'unlock', function () {

                    blocker.style.display = 'block';
                    instructions.style.display = '';

                } );

                scene.add( mousecontrols.getObject() );


                 
                const material = new THREE.MeshBasicMaterial( { map: texture } );

               //number of boxes, creating boxes and putting them in array

               //Xaxis takes from random from an array
               //Yaxis takes from random from an array
               //Z is completely random, from negative radius /2 to radius/2

                for(var i =0;i<num;i++) {//number of boxes
                mesh = new THREE.Mesh( geometry, material );
                mesh.castShadow = true; //default is false
                mesh.receiveShadow = false; //default
                scene.add( mesh );
                mesh.position.set(Xaxis[Math.floor(Math.random()*3)],Yaxis[Math.floor(Math.random()*2)],radius/2-radius*Math.random())

                obstacles.push(mesh);
                }



                //creating the floor
                 var floortexture = new THREE.TextureLoader().load("textures/grass.jpg");
                meshFloor = new THREE.Mesh(
                new THREE.PlaneGeometry(1000,2000,1000,1000),
                new THREE.MeshBasicMaterial({map: floortexture})
                );
               
                meshFloor.rotation.x -= Math.PI / 2; // Rotate the floor 90 degrees

                meshFloor.position.y -= 16; 
                scene.add(meshFloor);


                //creating the floor2
                 var floortexture2 = new THREE.TextureLoader().load("textures/greyfloor.jpg");
                 meshFloor2 = new THREE.Mesh(
                new THREE.PlaneGeometry(220,2000,1000,1000),
                new THREE.MeshBasicMaterial({color: 'grey'})
                );
               
                meshFloor2.rotation.x -= Math.PI / 2; // Rotate the floor 90 degrees

                meshFloor2.position.y -= 15; 
                meshFloor2.castShadow= false;
                meshFloor2.receiveShadow=true;
                scene.add(meshFloor2);

                //renderer = new THREE.WebGLRenderer( { antialias: true } );
                renderer.setPixelRatio( window.devicePixelRatio );
                renderer.setSize( window.innerWidth, window.innerHeight );
                document.body.appendChild( renderer.domElement );

               MaterialArray('penguins (30)');
                collision();
               
                window.addEventListener( 'resize', onWindowResize );
               window.addEventListener('keydown', movePlayer, false);
            }

//creating enviroment
function MaterialArray(filename){
var materialArray = [];
var texture_ft = new THREE.TextureLoader().load( 'textures/penguins-skybox-pack/penguins (30)/raspberry_ft.jpg');
var texture_bk = new THREE.TextureLoader().load( 'textures/penguins-skybox-pack/penguins (30)/raspberry_bk.jpg');
var texture_up = new THREE.TextureLoader().load( 'textures/penguins-skybox-pack/penguins (30)/raspberry_up.jpg');
var texture_dn = new THREE.TextureLoader().load('textures/penguins-skybox-pack/penguins (30)/raspberry_dn.jpg');
var texture_rt = new THREE.TextureLoader().load( 'textures/penguins-skybox-pack/penguins (30)/raspberry_rt.jpg');
var texture_lf = new THREE.TextureLoader().load( 'textures/penguins-skybox-pack/penguins (30)/raspberry_lf.jpg');
  
materialArray.push(new THREE.MeshBasicMaterial( { map: texture_ft }));
materialArray.push(new THREE.MeshBasicMaterial( { map: texture_bk }));
materialArray.push(new THREE.MeshBasicMaterial( { map: texture_up }));
materialArray.push(new THREE.MeshBasicMaterial( { map: texture_dn }));
materialArray.push(new THREE.MeshBasicMaterial( { map: texture_rt }));
materialArray.push(new THREE.MeshBasicMaterial( { map: texture_lf }));
   
for (let i = 0; i < 6; i++)
  materialArray[i].side = THREE.BackSide;
   
var skyboxGeo = new THREE.BoxGeometry( 10000, 10000, 10000);
var skybox = new THREE.Mesh( skyboxGeo, materialArray );
scene.add( skybox );

}
           //checking if camera position is inside the box's edges since it is never exact, by stating a range
            function collision(){
                for(var i =0;i<obstacles.length;i++){

                if(((camera.position.x>obstacles[i].position.x-10)&&(camera.position.x<obstacles[i].position.x+10)) && 
                    ((camera.position.y>obstacles[i].position.y-10)&&(camera.position.y<obstacles[i].position.y+10)) &&
                    ((camera.position.z>obstacles[i].position.z-10)&&(camera.position.z<obstacles[i].position.z+10))){


                   alert('game over');
                   window.cancelAnimationFrame(id);
                   //return back to the begining
                   obstacles[i].position.z=-600;
                   animate();
                }
            }

        }



           //update the renderer on the window
            function onWindowResize() {

                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();

                renderer.setSize( window.innerWidth, window.innerHeight );

            }

            
           // id to know which animation frame to cancel
           var id;
            function animate() {

                id = requestAnimationFrame( animate );
                jump();
                jumpMovement();

                //moving boxes
                for( var i = 0; i<obstacles.length;i++){
                    if(obstacles[i].position.z>=camera.position.z){
                        obstacles[i].position.z=-600; //return to the begining
                    }else{
                    obstacles[i].position.z += ObSpeed;
                    }
                    if (meshFloor.position.z>=100
                        ) {
                        meshFloor.position.z=-600;
                    }
                    else{
                        meshFloor.position.z+=0.2;
                    }
                    if (meshFloor2.position.z>=100
                        ) {
                        meshFloor2.position.z=-600;
                    }
                    else{
                        meshFloor2.position.z+=0.2;
                    }
                   // console.log(camera.position);
                }

              //to be called everytime a box moves
                collision();
                
                renderer.render( scene, camera );

            }

          
            function jump(){

              if(controls[32]) { // space
            
              if(player.jumps) //if he had already jumped he won't jump again

                return false;

              player.jumps = true;
              player.velocity = - player.jumpHeight; // - G
            }
          }



        function jumpMovement() { //jumping mechanism
        //going down
            player.velocity += player.gravity;
            camera.position.y -= player.velocity;
         //to not go under the floor
            if(camera.position.y < player.height) {

              camera.position.y = player.height;
              player.jumps = false;
            }
        }
           

        function movePlayer( evt ) {

        var dir = new THREE.Vector3( 100, 0, 0); //direction
       
        switch( evt.key ) {

         
          case 'a':
          //stops when reaching the edge
          if(camera.position.x == -100)
         {
 
          //do nothing          
         }
         else{
            //moves left
            camera.position.sub(dir);
           
           }
            break;

          case 'd':
          if(camera.position.x == 100)
         {
            //do nothing
          
         }
          else{ 
            //moves right
            camera.position.add(dir);
               
               }
                break;

           case 's':
           //crouch
                if(camera.position.y==25){
                    //if he is standing, he goes down
                    player.height=0;
                }else if(camera.position.y==0){
                    //if he is down, he stands up
                    player.height=25;
                }
                break;

        }
             
      window.addEventListener('keydown', movePlayer, false);

}


        </script>

    </body>
</html>
